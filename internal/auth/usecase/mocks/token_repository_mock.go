// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/lameroot/msa-messenger/internal/auth/usecase.TokenRepository -o token_repository_mock.go -n TokenRepositoryMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	auth_models "github.com/lameroot/msa-messenger/internal/auth/models"
)

// TokenRepositoryMock implements mm_auth_usecase.TokenRepository
type TokenRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccessToken          func(user *auth_models.User) (s1 string, err error)
	funcCreateAccessTokenOrigin    string
	inspectFuncCreateAccessToken   func(user *auth_models.User)
	afterCreateAccessTokenCounter  uint64
	beforeCreateAccessTokenCounter uint64
	CreateAccessTokenMock          mTokenRepositoryMockCreateAccessToken

	funcCreateRefreshToken          func(user *auth_models.User) (s1 string, err error)
	funcCreateRefreshTokenOrigin    string
	inspectFuncCreateRefreshToken   func(user *auth_models.User)
	afterCreateRefreshTokenCounter  uint64
	beforeCreateRefreshTokenCounter uint64
	CreateRefreshTokenMock          mTokenRepositoryMockCreateRefreshToken

	funcValidateAccessToken          func(tokenString string) (jp1 *auth_models.JWTClaims, err error)
	funcValidateAccessTokenOrigin    string
	inspectFuncValidateAccessToken   func(tokenString string)
	afterValidateAccessTokenCounter  uint64
	beforeValidateAccessTokenCounter uint64
	ValidateAccessTokenMock          mTokenRepositoryMockValidateAccessToken

	funcValidateRefreshToken          func(tokenString string) (jp1 *auth_models.JWTClaims, err error)
	funcValidateRefreshTokenOrigin    string
	inspectFuncValidateRefreshToken   func(tokenString string)
	afterValidateRefreshTokenCounter  uint64
	beforeValidateRefreshTokenCounter uint64
	ValidateRefreshTokenMock          mTokenRepositoryMockValidateRefreshToken
}

// NewTokenRepositoryMock returns a mock for mm_auth_usecase.TokenRepository
func NewTokenRepositoryMock(t minimock.Tester) *TokenRepositoryMock {
	m := &TokenRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccessTokenMock = mTokenRepositoryMockCreateAccessToken{mock: m}
	m.CreateAccessTokenMock.callArgs = []*TokenRepositoryMockCreateAccessTokenParams{}

	m.CreateRefreshTokenMock = mTokenRepositoryMockCreateRefreshToken{mock: m}
	m.CreateRefreshTokenMock.callArgs = []*TokenRepositoryMockCreateRefreshTokenParams{}

	m.ValidateAccessTokenMock = mTokenRepositoryMockValidateAccessToken{mock: m}
	m.ValidateAccessTokenMock.callArgs = []*TokenRepositoryMockValidateAccessTokenParams{}

	m.ValidateRefreshTokenMock = mTokenRepositoryMockValidateRefreshToken{mock: m}
	m.ValidateRefreshTokenMock.callArgs = []*TokenRepositoryMockValidateRefreshTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTokenRepositoryMockCreateAccessToken struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockCreateAccessTokenExpectation
	expectations       []*TokenRepositoryMockCreateAccessTokenExpectation

	callArgs []*TokenRepositoryMockCreateAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockCreateAccessTokenExpectation specifies expectation struct of the TokenRepository.CreateAccessToken
type TokenRepositoryMockCreateAccessTokenExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockCreateAccessTokenParams
	paramPtrs          *TokenRepositoryMockCreateAccessTokenParamPtrs
	expectationOrigins TokenRepositoryMockCreateAccessTokenExpectationOrigins
	results            *TokenRepositoryMockCreateAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockCreateAccessTokenParams contains parameters of the TokenRepository.CreateAccessToken
type TokenRepositoryMockCreateAccessTokenParams struct {
	user *auth_models.User
}

// TokenRepositoryMockCreateAccessTokenParamPtrs contains pointers to parameters of the TokenRepository.CreateAccessToken
type TokenRepositoryMockCreateAccessTokenParamPtrs struct {
	user **auth_models.User
}

// TokenRepositoryMockCreateAccessTokenResults contains results of the TokenRepository.CreateAccessToken
type TokenRepositoryMockCreateAccessTokenResults struct {
	s1  string
	err error
}

// TokenRepositoryMockCreateAccessTokenOrigins contains origins of expectations of the TokenRepository.CreateAccessToken
type TokenRepositoryMockCreateAccessTokenExpectationOrigins struct {
	origin     string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Optional() *mTokenRepositoryMockCreateAccessToken {
	mmCreateAccessToken.optional = true
	return mmCreateAccessToken
}

// Expect sets up expected params for TokenRepository.CreateAccessToken
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Expect(user *auth_models.User) *mTokenRepositoryMockCreateAccessToken {
	if mmCreateAccessToken.mock.funcCreateAccessToken != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by Set")
	}

	if mmCreateAccessToken.defaultExpectation == nil {
		mmCreateAccessToken.defaultExpectation = &TokenRepositoryMockCreateAccessTokenExpectation{}
	}

	if mmCreateAccessToken.defaultExpectation.paramPtrs != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by ExpectParams functions")
	}

	mmCreateAccessToken.defaultExpectation.params = &TokenRepositoryMockCreateAccessTokenParams{user}
	mmCreateAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccessToken.expectations {
		if minimock.Equal(e.params, mmCreateAccessToken.defaultExpectation.params) {
			mmCreateAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccessToken.defaultExpectation.params)
		}
	}

	return mmCreateAccessToken
}

// ExpectUserParam1 sets up expected param user for TokenRepository.CreateAccessToken
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) ExpectUserParam1(user *auth_models.User) *mTokenRepositoryMockCreateAccessToken {
	if mmCreateAccessToken.mock.funcCreateAccessToken != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by Set")
	}

	if mmCreateAccessToken.defaultExpectation == nil {
		mmCreateAccessToken.defaultExpectation = &TokenRepositoryMockCreateAccessTokenExpectation{}
	}

	if mmCreateAccessToken.defaultExpectation.params != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by Expect")
	}

	if mmCreateAccessToken.defaultExpectation.paramPtrs == nil {
		mmCreateAccessToken.defaultExpectation.paramPtrs = &TokenRepositoryMockCreateAccessTokenParamPtrs{}
	}
	mmCreateAccessToken.defaultExpectation.paramPtrs.user = &user
	mmCreateAccessToken.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateAccessToken
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.CreateAccessToken
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Inspect(f func(user *auth_models.User)) *mTokenRepositoryMockCreateAccessToken {
	if mmCreateAccessToken.mock.inspectFuncCreateAccessToken != nil {
		mmCreateAccessToken.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.CreateAccessToken")
	}

	mmCreateAccessToken.mock.inspectFuncCreateAccessToken = f

	return mmCreateAccessToken
}

// Return sets up results that will be returned by TokenRepository.CreateAccessToken
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Return(s1 string, err error) *TokenRepositoryMock {
	if mmCreateAccessToken.mock.funcCreateAccessToken != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by Set")
	}

	if mmCreateAccessToken.defaultExpectation == nil {
		mmCreateAccessToken.defaultExpectation = &TokenRepositoryMockCreateAccessTokenExpectation{mock: mmCreateAccessToken.mock}
	}
	mmCreateAccessToken.defaultExpectation.results = &TokenRepositoryMockCreateAccessTokenResults{s1, err}
	mmCreateAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccessToken.mock
}

// Set uses given function f to mock the TokenRepository.CreateAccessToken method
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Set(f func(user *auth_models.User) (s1 string, err error)) *TokenRepositoryMock {
	if mmCreateAccessToken.defaultExpectation != nil {
		mmCreateAccessToken.mock.t.Fatalf("Default expectation is already set for the TokenRepository.CreateAccessToken method")
	}

	if len(mmCreateAccessToken.expectations) > 0 {
		mmCreateAccessToken.mock.t.Fatalf("Some expectations are already set for the TokenRepository.CreateAccessToken method")
	}

	mmCreateAccessToken.mock.funcCreateAccessToken = f
	mmCreateAccessToken.mock.funcCreateAccessTokenOrigin = minimock.CallerInfo(1)
	return mmCreateAccessToken.mock
}

// When sets expectation for the TokenRepository.CreateAccessToken which will trigger the result defined by the following
// Then helper
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) When(user *auth_models.User) *TokenRepositoryMockCreateAccessTokenExpectation {
	if mmCreateAccessToken.mock.funcCreateAccessToken != nil {
		mmCreateAccessToken.mock.t.Fatalf("TokenRepositoryMock.CreateAccessToken mock is already set by Set")
	}

	expectation := &TokenRepositoryMockCreateAccessTokenExpectation{
		mock:               mmCreateAccessToken.mock,
		params:             &TokenRepositoryMockCreateAccessTokenParams{user},
		expectationOrigins: TokenRepositoryMockCreateAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccessToken.expectations = append(mmCreateAccessToken.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.CreateAccessToken return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockCreateAccessTokenExpectation) Then(s1 string, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockCreateAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times TokenRepository.CreateAccessToken should be invoked
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Times(n uint64) *mTokenRepositoryMockCreateAccessToken {
	if n == 0 {
		mmCreateAccessToken.mock.t.Fatalf("Times of TokenRepositoryMock.CreateAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccessToken.expectedInvocations, n)
	mmCreateAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccessToken
}

func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) invocationsDone() bool {
	if len(mmCreateAccessToken.expectations) == 0 && mmCreateAccessToken.defaultExpectation == nil && mmCreateAccessToken.mock.funcCreateAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccessToken.mock.afterCreateAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccessToken implements mm_auth_usecase.TokenRepository
func (mmCreateAccessToken *TokenRepositoryMock) CreateAccessToken(user *auth_models.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateAccessToken.beforeCreateAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccessToken.afterCreateAccessTokenCounter, 1)

	mmCreateAccessToken.t.Helper()

	if mmCreateAccessToken.inspectFuncCreateAccessToken != nil {
		mmCreateAccessToken.inspectFuncCreateAccessToken(user)
	}

	mm_params := TokenRepositoryMockCreateAccessTokenParams{user}

	// Record call args
	mmCreateAccessToken.CreateAccessTokenMock.mutex.Lock()
	mmCreateAccessToken.CreateAccessTokenMock.callArgs = append(mmCreateAccessToken.CreateAccessTokenMock.callArgs, &mm_params)
	mmCreateAccessToken.CreateAccessTokenMock.mutex.Unlock()

	for _, e := range mmCreateAccessToken.CreateAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockCreateAccessTokenParams{user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateAccessToken.t.Errorf("TokenRepositoryMock.CreateAccessToken got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccessToken.t.Errorf("TokenRepositoryMock.CreateAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccessToken.CreateAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccessToken.t.Fatal("No results are set for the TokenRepositoryMock.CreateAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreateAccessToken.funcCreateAccessToken != nil {
		return mmCreateAccessToken.funcCreateAccessToken(user)
	}
	mmCreateAccessToken.t.Fatalf("Unexpected call to TokenRepositoryMock.CreateAccessToken. %v", user)
	return
}

// CreateAccessTokenAfterCounter returns a count of finished TokenRepositoryMock.CreateAccessToken invocations
func (mmCreateAccessToken *TokenRepositoryMock) CreateAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessToken.afterCreateAccessTokenCounter)
}

// CreateAccessTokenBeforeCounter returns a count of TokenRepositoryMock.CreateAccessToken invocations
func (mmCreateAccessToken *TokenRepositoryMock) CreateAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessToken.beforeCreateAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.CreateAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccessToken *mTokenRepositoryMockCreateAccessToken) Calls() []*TokenRepositoryMockCreateAccessTokenParams {
	mmCreateAccessToken.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockCreateAccessTokenParams, len(mmCreateAccessToken.callArgs))
	copy(argCopy, mmCreateAccessToken.callArgs)

	mmCreateAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessTokenDone returns true if the count of the CreateAccessToken invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockCreateAccessTokenDone() bool {
	if m.CreateAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccessTokenMock.invocationsDone()
}

// MinimockCreateAccessTokenInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockCreateAccessTokenInspect() {
	for _, e := range m.CreateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccessTokenCounter := mm_atomic.LoadUint64(&m.afterCreateAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessTokenMock.defaultExpectation != nil && afterCreateAccessTokenCounter < 1 {
		if m.CreateAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateAccessToken at\n%s", m.CreateAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateAccessToken at\n%s with params: %#v", m.CreateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccessToken != nil && afterCreateAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.CreateAccessToken at\n%s", m.funcCreateAccessTokenOrigin)
	}

	if !m.CreateAccessTokenMock.invocationsDone() && afterCreateAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.CreateAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccessTokenMock.expectedInvocations), m.CreateAccessTokenMock.expectedInvocationsOrigin, afterCreateAccessTokenCounter)
	}
}

type mTokenRepositoryMockCreateRefreshToken struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockCreateRefreshTokenExpectation
	expectations       []*TokenRepositoryMockCreateRefreshTokenExpectation

	callArgs []*TokenRepositoryMockCreateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockCreateRefreshTokenExpectation specifies expectation struct of the TokenRepository.CreateRefreshToken
type TokenRepositoryMockCreateRefreshTokenExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockCreateRefreshTokenParams
	paramPtrs          *TokenRepositoryMockCreateRefreshTokenParamPtrs
	expectationOrigins TokenRepositoryMockCreateRefreshTokenExpectationOrigins
	results            *TokenRepositoryMockCreateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockCreateRefreshTokenParams contains parameters of the TokenRepository.CreateRefreshToken
type TokenRepositoryMockCreateRefreshTokenParams struct {
	user *auth_models.User
}

// TokenRepositoryMockCreateRefreshTokenParamPtrs contains pointers to parameters of the TokenRepository.CreateRefreshToken
type TokenRepositoryMockCreateRefreshTokenParamPtrs struct {
	user **auth_models.User
}

// TokenRepositoryMockCreateRefreshTokenResults contains results of the TokenRepository.CreateRefreshToken
type TokenRepositoryMockCreateRefreshTokenResults struct {
	s1  string
	err error
}

// TokenRepositoryMockCreateRefreshTokenOrigins contains origins of expectations of the TokenRepository.CreateRefreshToken
type TokenRepositoryMockCreateRefreshTokenExpectationOrigins struct {
	origin     string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Optional() *mTokenRepositoryMockCreateRefreshToken {
	mmCreateRefreshToken.optional = true
	return mmCreateRefreshToken
}

// Expect sets up expected params for TokenRepository.CreateRefreshToken
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Expect(user *auth_models.User) *mTokenRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &TokenRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by ExpectParams functions")
	}

	mmCreateRefreshToken.defaultExpectation.params = &TokenRepositoryMockCreateRefreshTokenParams{user}
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRefreshToken.expectations {
		if minimock.Equal(e.params, mmCreateRefreshToken.defaultExpectation.params) {
			mmCreateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRefreshToken.defaultExpectation.params)
		}
	}

	return mmCreateRefreshToken
}

// ExpectUserParam1 sets up expected param user for TokenRepository.CreateRefreshToken
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) ExpectUserParam1(user *auth_models.User) *mTokenRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &TokenRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.params != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by Expect")
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmCreateRefreshToken.defaultExpectation.paramPtrs = &TokenRepositoryMockCreateRefreshTokenParamPtrs{}
	}
	mmCreateRefreshToken.defaultExpectation.paramPtrs.user = &user
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.CreateRefreshToken
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Inspect(f func(user *auth_models.User)) *mTokenRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.inspectFuncCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.CreateRefreshToken")
	}

	mmCreateRefreshToken.mock.inspectFuncCreateRefreshToken = f

	return mmCreateRefreshToken
}

// Return sets up results that will be returned by TokenRepository.CreateRefreshToken
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Return(s1 string, err error) *TokenRepositoryMock {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &TokenRepositoryMockCreateRefreshTokenExpectation{mock: mmCreateRefreshToken.mock}
	}
	mmCreateRefreshToken.defaultExpectation.results = &TokenRepositoryMockCreateRefreshTokenResults{s1, err}
	mmCreateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken.mock
}

// Set uses given function f to mock the TokenRepository.CreateRefreshToken method
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Set(f func(user *auth_models.User) (s1 string, err error)) *TokenRepositoryMock {
	if mmCreateRefreshToken.defaultExpectation != nil {
		mmCreateRefreshToken.mock.t.Fatalf("Default expectation is already set for the TokenRepository.CreateRefreshToken method")
	}

	if len(mmCreateRefreshToken.expectations) > 0 {
		mmCreateRefreshToken.mock.t.Fatalf("Some expectations are already set for the TokenRepository.CreateRefreshToken method")
	}

	mmCreateRefreshToken.mock.funcCreateRefreshToken = f
	mmCreateRefreshToken.mock.funcCreateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken.mock
}

// When sets expectation for the TokenRepository.CreateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) When(user *auth_models.User) *TokenRepositoryMockCreateRefreshTokenExpectation {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	expectation := &TokenRepositoryMockCreateRefreshTokenExpectation{
		mock:               mmCreateRefreshToken.mock,
		params:             &TokenRepositoryMockCreateRefreshTokenParams{user},
		expectationOrigins: TokenRepositoryMockCreateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRefreshToken.expectations = append(mmCreateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.CreateRefreshToken return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockCreateRefreshTokenExpectation) Then(s1 string, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockCreateRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times TokenRepository.CreateRefreshToken should be invoked
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Times(n uint64) *mTokenRepositoryMockCreateRefreshToken {
	if n == 0 {
		mmCreateRefreshToken.mock.t.Fatalf("Times of TokenRepositoryMock.CreateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRefreshToken.expectedInvocations, n)
	mmCreateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken
}

func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) invocationsDone() bool {
	if len(mmCreateRefreshToken.expectations) == 0 && mmCreateRefreshToken.defaultExpectation == nil && mmCreateRefreshToken.mock.funcCreateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRefreshToken.mock.afterCreateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRefreshToken implements mm_auth_usecase.TokenRepository
func (mmCreateRefreshToken *TokenRepositoryMock) CreateRefreshToken(user *auth_models.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreateRefreshToken.beforeCreateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRefreshToken.afterCreateRefreshTokenCounter, 1)

	mmCreateRefreshToken.t.Helper()

	if mmCreateRefreshToken.inspectFuncCreateRefreshToken != nil {
		mmCreateRefreshToken.inspectFuncCreateRefreshToken(user)
	}

	mm_params := TokenRepositoryMockCreateRefreshTokenParams{user}

	// Record call args
	mmCreateRefreshToken.CreateRefreshTokenMock.mutex.Lock()
	mmCreateRefreshToken.CreateRefreshTokenMock.callArgs = append(mmCreateRefreshToken.CreateRefreshTokenMock.callArgs, &mm_params)
	mmCreateRefreshToken.CreateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmCreateRefreshToken.CreateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockCreateRefreshTokenParams{user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateRefreshToken.t.Errorf("TokenRepositoryMock.CreateRefreshToken got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRefreshToken.t.Errorf("TokenRepositoryMock.CreateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRefreshToken.t.Fatal("No results are set for the TokenRepositoryMock.CreateRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreateRefreshToken.funcCreateRefreshToken != nil {
		return mmCreateRefreshToken.funcCreateRefreshToken(user)
	}
	mmCreateRefreshToken.t.Fatalf("Unexpected call to TokenRepositoryMock.CreateRefreshToken. %v", user)
	return
}

// CreateRefreshTokenAfterCounter returns a count of finished TokenRepositoryMock.CreateRefreshToken invocations
func (mmCreateRefreshToken *TokenRepositoryMock) CreateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRefreshToken.afterCreateRefreshTokenCounter)
}

// CreateRefreshTokenBeforeCounter returns a count of TokenRepositoryMock.CreateRefreshToken invocations
func (mmCreateRefreshToken *TokenRepositoryMock) CreateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRefreshToken.beforeCreateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.CreateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRefreshToken *mTokenRepositoryMockCreateRefreshToken) Calls() []*TokenRepositoryMockCreateRefreshTokenParams {
	mmCreateRefreshToken.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockCreateRefreshTokenParams, len(mmCreateRefreshToken.callArgs))
	copy(argCopy, mmCreateRefreshToken.callArgs)

	mmCreateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRefreshTokenDone returns true if the count of the CreateRefreshToken invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockCreateRefreshTokenDone() bool {
	if m.CreateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRefreshTokenMock.invocationsDone()
}

// MinimockCreateRefreshTokenInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockCreateRefreshTokenInspect() {
	for _, e := range m.CreateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterCreateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRefreshTokenMock.defaultExpectation != nil && afterCreateRefreshTokenCounter < 1 {
		if m.CreateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateRefreshToken at\n%s", m.CreateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.CreateRefreshToken at\n%s with params: %#v", m.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.CreateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRefreshToken != nil && afterCreateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.CreateRefreshToken at\n%s", m.funcCreateRefreshTokenOrigin)
	}

	if !m.CreateRefreshTokenMock.invocationsDone() && afterCreateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.CreateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRefreshTokenMock.expectedInvocations), m.CreateRefreshTokenMock.expectedInvocationsOrigin, afterCreateRefreshTokenCounter)
	}
}

type mTokenRepositoryMockValidateAccessToken struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockValidateAccessTokenExpectation
	expectations       []*TokenRepositoryMockValidateAccessTokenExpectation

	callArgs []*TokenRepositoryMockValidateAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockValidateAccessTokenExpectation specifies expectation struct of the TokenRepository.ValidateAccessToken
type TokenRepositoryMockValidateAccessTokenExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockValidateAccessTokenParams
	paramPtrs          *TokenRepositoryMockValidateAccessTokenParamPtrs
	expectationOrigins TokenRepositoryMockValidateAccessTokenExpectationOrigins
	results            *TokenRepositoryMockValidateAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockValidateAccessTokenParams contains parameters of the TokenRepository.ValidateAccessToken
type TokenRepositoryMockValidateAccessTokenParams struct {
	tokenString string
}

// TokenRepositoryMockValidateAccessTokenParamPtrs contains pointers to parameters of the TokenRepository.ValidateAccessToken
type TokenRepositoryMockValidateAccessTokenParamPtrs struct {
	tokenString *string
}

// TokenRepositoryMockValidateAccessTokenResults contains results of the TokenRepository.ValidateAccessToken
type TokenRepositoryMockValidateAccessTokenResults struct {
	jp1 *auth_models.JWTClaims
	err error
}

// TokenRepositoryMockValidateAccessTokenOrigins contains origins of expectations of the TokenRepository.ValidateAccessToken
type TokenRepositoryMockValidateAccessTokenExpectationOrigins struct {
	origin            string
	originTokenString string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Optional() *mTokenRepositoryMockValidateAccessToken {
	mmValidateAccessToken.optional = true
	return mmValidateAccessToken
}

// Expect sets up expected params for TokenRepository.ValidateAccessToken
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Expect(tokenString string) *mTokenRepositoryMockValidateAccessToken {
	if mmValidateAccessToken.mock.funcValidateAccessToken != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by Set")
	}

	if mmValidateAccessToken.defaultExpectation == nil {
		mmValidateAccessToken.defaultExpectation = &TokenRepositoryMockValidateAccessTokenExpectation{}
	}

	if mmValidateAccessToken.defaultExpectation.paramPtrs != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by ExpectParams functions")
	}

	mmValidateAccessToken.defaultExpectation.params = &TokenRepositoryMockValidateAccessTokenParams{tokenString}
	mmValidateAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateAccessToken.expectations {
		if minimock.Equal(e.params, mmValidateAccessToken.defaultExpectation.params) {
			mmValidateAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateAccessToken.defaultExpectation.params)
		}
	}

	return mmValidateAccessToken
}

// ExpectTokenStringParam1 sets up expected param tokenString for TokenRepository.ValidateAccessToken
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) ExpectTokenStringParam1(tokenString string) *mTokenRepositoryMockValidateAccessToken {
	if mmValidateAccessToken.mock.funcValidateAccessToken != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by Set")
	}

	if mmValidateAccessToken.defaultExpectation == nil {
		mmValidateAccessToken.defaultExpectation = &TokenRepositoryMockValidateAccessTokenExpectation{}
	}

	if mmValidateAccessToken.defaultExpectation.params != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by Expect")
	}

	if mmValidateAccessToken.defaultExpectation.paramPtrs == nil {
		mmValidateAccessToken.defaultExpectation.paramPtrs = &TokenRepositoryMockValidateAccessTokenParamPtrs{}
	}
	mmValidateAccessToken.defaultExpectation.paramPtrs.tokenString = &tokenString
	mmValidateAccessToken.defaultExpectation.expectationOrigins.originTokenString = minimock.CallerInfo(1)

	return mmValidateAccessToken
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.ValidateAccessToken
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Inspect(f func(tokenString string)) *mTokenRepositoryMockValidateAccessToken {
	if mmValidateAccessToken.mock.inspectFuncValidateAccessToken != nil {
		mmValidateAccessToken.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.ValidateAccessToken")
	}

	mmValidateAccessToken.mock.inspectFuncValidateAccessToken = f

	return mmValidateAccessToken
}

// Return sets up results that will be returned by TokenRepository.ValidateAccessToken
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Return(jp1 *auth_models.JWTClaims, err error) *TokenRepositoryMock {
	if mmValidateAccessToken.mock.funcValidateAccessToken != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by Set")
	}

	if mmValidateAccessToken.defaultExpectation == nil {
		mmValidateAccessToken.defaultExpectation = &TokenRepositoryMockValidateAccessTokenExpectation{mock: mmValidateAccessToken.mock}
	}
	mmValidateAccessToken.defaultExpectation.results = &TokenRepositoryMockValidateAccessTokenResults{jp1, err}
	mmValidateAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateAccessToken.mock
}

// Set uses given function f to mock the TokenRepository.ValidateAccessToken method
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Set(f func(tokenString string) (jp1 *auth_models.JWTClaims, err error)) *TokenRepositoryMock {
	if mmValidateAccessToken.defaultExpectation != nil {
		mmValidateAccessToken.mock.t.Fatalf("Default expectation is already set for the TokenRepository.ValidateAccessToken method")
	}

	if len(mmValidateAccessToken.expectations) > 0 {
		mmValidateAccessToken.mock.t.Fatalf("Some expectations are already set for the TokenRepository.ValidateAccessToken method")
	}

	mmValidateAccessToken.mock.funcValidateAccessToken = f
	mmValidateAccessToken.mock.funcValidateAccessTokenOrigin = minimock.CallerInfo(1)
	return mmValidateAccessToken.mock
}

// When sets expectation for the TokenRepository.ValidateAccessToken which will trigger the result defined by the following
// Then helper
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) When(tokenString string) *TokenRepositoryMockValidateAccessTokenExpectation {
	if mmValidateAccessToken.mock.funcValidateAccessToken != nil {
		mmValidateAccessToken.mock.t.Fatalf("TokenRepositoryMock.ValidateAccessToken mock is already set by Set")
	}

	expectation := &TokenRepositoryMockValidateAccessTokenExpectation{
		mock:               mmValidateAccessToken.mock,
		params:             &TokenRepositoryMockValidateAccessTokenParams{tokenString},
		expectationOrigins: TokenRepositoryMockValidateAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateAccessToken.expectations = append(mmValidateAccessToken.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.ValidateAccessToken return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockValidateAccessTokenExpectation) Then(jp1 *auth_models.JWTClaims, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockValidateAccessTokenResults{jp1, err}
	return e.mock
}

// Times sets number of times TokenRepository.ValidateAccessToken should be invoked
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Times(n uint64) *mTokenRepositoryMockValidateAccessToken {
	if n == 0 {
		mmValidateAccessToken.mock.t.Fatalf("Times of TokenRepositoryMock.ValidateAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateAccessToken.expectedInvocations, n)
	mmValidateAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateAccessToken
}

func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) invocationsDone() bool {
	if len(mmValidateAccessToken.expectations) == 0 && mmValidateAccessToken.defaultExpectation == nil && mmValidateAccessToken.mock.funcValidateAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateAccessToken.mock.afterValidateAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateAccessToken implements mm_auth_usecase.TokenRepository
func (mmValidateAccessToken *TokenRepositoryMock) ValidateAccessToken(tokenString string) (jp1 *auth_models.JWTClaims, err error) {
	mm_atomic.AddUint64(&mmValidateAccessToken.beforeValidateAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateAccessToken.afterValidateAccessTokenCounter, 1)

	mmValidateAccessToken.t.Helper()

	if mmValidateAccessToken.inspectFuncValidateAccessToken != nil {
		mmValidateAccessToken.inspectFuncValidateAccessToken(tokenString)
	}

	mm_params := TokenRepositoryMockValidateAccessTokenParams{tokenString}

	// Record call args
	mmValidateAccessToken.ValidateAccessTokenMock.mutex.Lock()
	mmValidateAccessToken.ValidateAccessTokenMock.callArgs = append(mmValidateAccessToken.ValidateAccessTokenMock.callArgs, &mm_params)
	mmValidateAccessToken.ValidateAccessTokenMock.mutex.Unlock()

	for _, e := range mmValidateAccessToken.ValidateAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockValidateAccessTokenParams{tokenString}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tokenString != nil && !minimock.Equal(*mm_want_ptrs.tokenString, mm_got.tokenString) {
				mmValidateAccessToken.t.Errorf("TokenRepositoryMock.ValidateAccessToken got unexpected parameter tokenString, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.expectationOrigins.originTokenString, *mm_want_ptrs.tokenString, mm_got.tokenString, minimock.Diff(*mm_want_ptrs.tokenString, mm_got.tokenString))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateAccessToken.t.Errorf("TokenRepositoryMock.ValidateAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateAccessToken.ValidateAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateAccessToken.t.Fatal("No results are set for the TokenRepositoryMock.ValidateAccessToken")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmValidateAccessToken.funcValidateAccessToken != nil {
		return mmValidateAccessToken.funcValidateAccessToken(tokenString)
	}
	mmValidateAccessToken.t.Fatalf("Unexpected call to TokenRepositoryMock.ValidateAccessToken. %v", tokenString)
	return
}

// ValidateAccessTokenAfterCounter returns a count of finished TokenRepositoryMock.ValidateAccessToken invocations
func (mmValidateAccessToken *TokenRepositoryMock) ValidateAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateAccessToken.afterValidateAccessTokenCounter)
}

// ValidateAccessTokenBeforeCounter returns a count of TokenRepositoryMock.ValidateAccessToken invocations
func (mmValidateAccessToken *TokenRepositoryMock) ValidateAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateAccessToken.beforeValidateAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.ValidateAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateAccessToken *mTokenRepositoryMockValidateAccessToken) Calls() []*TokenRepositoryMockValidateAccessTokenParams {
	mmValidateAccessToken.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockValidateAccessTokenParams, len(mmValidateAccessToken.callArgs))
	copy(argCopy, mmValidateAccessToken.callArgs)

	mmValidateAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockValidateAccessTokenDone returns true if the count of the ValidateAccessToken invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockValidateAccessTokenDone() bool {
	if m.ValidateAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateAccessTokenMock.invocationsDone()
}

// MinimockValidateAccessTokenInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockValidateAccessTokenInspect() {
	for _, e := range m.ValidateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateAccessTokenCounter := mm_atomic.LoadUint64(&m.afterValidateAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateAccessTokenMock.defaultExpectation != nil && afterValidateAccessTokenCounter < 1 {
		if m.ValidateAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateAccessToken at\n%s", m.ValidateAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateAccessToken at\n%s with params: %#v", m.ValidateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.ValidateAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateAccessToken != nil && afterValidateAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.ValidateAccessToken at\n%s", m.funcValidateAccessTokenOrigin)
	}

	if !m.ValidateAccessTokenMock.invocationsDone() && afterValidateAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.ValidateAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateAccessTokenMock.expectedInvocations), m.ValidateAccessTokenMock.expectedInvocationsOrigin, afterValidateAccessTokenCounter)
	}
}

type mTokenRepositoryMockValidateRefreshToken struct {
	optional           bool
	mock               *TokenRepositoryMock
	defaultExpectation *TokenRepositoryMockValidateRefreshTokenExpectation
	expectations       []*TokenRepositoryMockValidateRefreshTokenExpectation

	callArgs []*TokenRepositoryMockValidateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TokenRepositoryMockValidateRefreshTokenExpectation specifies expectation struct of the TokenRepository.ValidateRefreshToken
type TokenRepositoryMockValidateRefreshTokenExpectation struct {
	mock               *TokenRepositoryMock
	params             *TokenRepositoryMockValidateRefreshTokenParams
	paramPtrs          *TokenRepositoryMockValidateRefreshTokenParamPtrs
	expectationOrigins TokenRepositoryMockValidateRefreshTokenExpectationOrigins
	results            *TokenRepositoryMockValidateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// TokenRepositoryMockValidateRefreshTokenParams contains parameters of the TokenRepository.ValidateRefreshToken
type TokenRepositoryMockValidateRefreshTokenParams struct {
	tokenString string
}

// TokenRepositoryMockValidateRefreshTokenParamPtrs contains pointers to parameters of the TokenRepository.ValidateRefreshToken
type TokenRepositoryMockValidateRefreshTokenParamPtrs struct {
	tokenString *string
}

// TokenRepositoryMockValidateRefreshTokenResults contains results of the TokenRepository.ValidateRefreshToken
type TokenRepositoryMockValidateRefreshTokenResults struct {
	jp1 *auth_models.JWTClaims
	err error
}

// TokenRepositoryMockValidateRefreshTokenOrigins contains origins of expectations of the TokenRepository.ValidateRefreshToken
type TokenRepositoryMockValidateRefreshTokenExpectationOrigins struct {
	origin            string
	originTokenString string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Optional() *mTokenRepositoryMockValidateRefreshToken {
	mmValidateRefreshToken.optional = true
	return mmValidateRefreshToken
}

// Expect sets up expected params for TokenRepository.ValidateRefreshToken
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Expect(tokenString string) *mTokenRepositoryMockValidateRefreshToken {
	if mmValidateRefreshToken.mock.funcValidateRefreshToken != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by Set")
	}

	if mmValidateRefreshToken.defaultExpectation == nil {
		mmValidateRefreshToken.defaultExpectation = &TokenRepositoryMockValidateRefreshTokenExpectation{}
	}

	if mmValidateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by ExpectParams functions")
	}

	mmValidateRefreshToken.defaultExpectation.params = &TokenRepositoryMockValidateRefreshTokenParams{tokenString}
	mmValidateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateRefreshToken.expectations {
		if minimock.Equal(e.params, mmValidateRefreshToken.defaultExpectation.params) {
			mmValidateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateRefreshToken.defaultExpectation.params)
		}
	}

	return mmValidateRefreshToken
}

// ExpectTokenStringParam1 sets up expected param tokenString for TokenRepository.ValidateRefreshToken
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) ExpectTokenStringParam1(tokenString string) *mTokenRepositoryMockValidateRefreshToken {
	if mmValidateRefreshToken.mock.funcValidateRefreshToken != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by Set")
	}

	if mmValidateRefreshToken.defaultExpectation == nil {
		mmValidateRefreshToken.defaultExpectation = &TokenRepositoryMockValidateRefreshTokenExpectation{}
	}

	if mmValidateRefreshToken.defaultExpectation.params != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by Expect")
	}

	if mmValidateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmValidateRefreshToken.defaultExpectation.paramPtrs = &TokenRepositoryMockValidateRefreshTokenParamPtrs{}
	}
	mmValidateRefreshToken.defaultExpectation.paramPtrs.tokenString = &tokenString
	mmValidateRefreshToken.defaultExpectation.expectationOrigins.originTokenString = minimock.CallerInfo(1)

	return mmValidateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the TokenRepository.ValidateRefreshToken
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Inspect(f func(tokenString string)) *mTokenRepositoryMockValidateRefreshToken {
	if mmValidateRefreshToken.mock.inspectFuncValidateRefreshToken != nil {
		mmValidateRefreshToken.mock.t.Fatalf("Inspect function is already set for TokenRepositoryMock.ValidateRefreshToken")
	}

	mmValidateRefreshToken.mock.inspectFuncValidateRefreshToken = f

	return mmValidateRefreshToken
}

// Return sets up results that will be returned by TokenRepository.ValidateRefreshToken
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Return(jp1 *auth_models.JWTClaims, err error) *TokenRepositoryMock {
	if mmValidateRefreshToken.mock.funcValidateRefreshToken != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by Set")
	}

	if mmValidateRefreshToken.defaultExpectation == nil {
		mmValidateRefreshToken.defaultExpectation = &TokenRepositoryMockValidateRefreshTokenExpectation{mock: mmValidateRefreshToken.mock}
	}
	mmValidateRefreshToken.defaultExpectation.results = &TokenRepositoryMockValidateRefreshTokenResults{jp1, err}
	mmValidateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateRefreshToken.mock
}

// Set uses given function f to mock the TokenRepository.ValidateRefreshToken method
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Set(f func(tokenString string) (jp1 *auth_models.JWTClaims, err error)) *TokenRepositoryMock {
	if mmValidateRefreshToken.defaultExpectation != nil {
		mmValidateRefreshToken.mock.t.Fatalf("Default expectation is already set for the TokenRepository.ValidateRefreshToken method")
	}

	if len(mmValidateRefreshToken.expectations) > 0 {
		mmValidateRefreshToken.mock.t.Fatalf("Some expectations are already set for the TokenRepository.ValidateRefreshToken method")
	}

	mmValidateRefreshToken.mock.funcValidateRefreshToken = f
	mmValidateRefreshToken.mock.funcValidateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmValidateRefreshToken.mock
}

// When sets expectation for the TokenRepository.ValidateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) When(tokenString string) *TokenRepositoryMockValidateRefreshTokenExpectation {
	if mmValidateRefreshToken.mock.funcValidateRefreshToken != nil {
		mmValidateRefreshToken.mock.t.Fatalf("TokenRepositoryMock.ValidateRefreshToken mock is already set by Set")
	}

	expectation := &TokenRepositoryMockValidateRefreshTokenExpectation{
		mock:               mmValidateRefreshToken.mock,
		params:             &TokenRepositoryMockValidateRefreshTokenParams{tokenString},
		expectationOrigins: TokenRepositoryMockValidateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateRefreshToken.expectations = append(mmValidateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up TokenRepository.ValidateRefreshToken return parameters for the expectation previously defined by the When method
func (e *TokenRepositoryMockValidateRefreshTokenExpectation) Then(jp1 *auth_models.JWTClaims, err error) *TokenRepositoryMock {
	e.results = &TokenRepositoryMockValidateRefreshTokenResults{jp1, err}
	return e.mock
}

// Times sets number of times TokenRepository.ValidateRefreshToken should be invoked
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Times(n uint64) *mTokenRepositoryMockValidateRefreshToken {
	if n == 0 {
		mmValidateRefreshToken.mock.t.Fatalf("Times of TokenRepositoryMock.ValidateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateRefreshToken.expectedInvocations, n)
	mmValidateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateRefreshToken
}

func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) invocationsDone() bool {
	if len(mmValidateRefreshToken.expectations) == 0 && mmValidateRefreshToken.defaultExpectation == nil && mmValidateRefreshToken.mock.funcValidateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateRefreshToken.mock.afterValidateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateRefreshToken implements mm_auth_usecase.TokenRepository
func (mmValidateRefreshToken *TokenRepositoryMock) ValidateRefreshToken(tokenString string) (jp1 *auth_models.JWTClaims, err error) {
	mm_atomic.AddUint64(&mmValidateRefreshToken.beforeValidateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateRefreshToken.afterValidateRefreshTokenCounter, 1)

	mmValidateRefreshToken.t.Helper()

	if mmValidateRefreshToken.inspectFuncValidateRefreshToken != nil {
		mmValidateRefreshToken.inspectFuncValidateRefreshToken(tokenString)
	}

	mm_params := TokenRepositoryMockValidateRefreshTokenParams{tokenString}

	// Record call args
	mmValidateRefreshToken.ValidateRefreshTokenMock.mutex.Lock()
	mmValidateRefreshToken.ValidateRefreshTokenMock.callArgs = append(mmValidateRefreshToken.ValidateRefreshTokenMock.callArgs, &mm_params)
	mmValidateRefreshToken.ValidateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmValidateRefreshToken.ValidateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := TokenRepositoryMockValidateRefreshTokenParams{tokenString}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tokenString != nil && !minimock.Equal(*mm_want_ptrs.tokenString, mm_got.tokenString) {
				mmValidateRefreshToken.t.Errorf("TokenRepositoryMock.ValidateRefreshToken got unexpected parameter tokenString, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.expectationOrigins.originTokenString, *mm_want_ptrs.tokenString, mm_got.tokenString, minimock.Diff(*mm_want_ptrs.tokenString, mm_got.tokenString))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateRefreshToken.t.Errorf("TokenRepositoryMock.ValidateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateRefreshToken.ValidateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateRefreshToken.t.Fatal("No results are set for the TokenRepositoryMock.ValidateRefreshToken")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmValidateRefreshToken.funcValidateRefreshToken != nil {
		return mmValidateRefreshToken.funcValidateRefreshToken(tokenString)
	}
	mmValidateRefreshToken.t.Fatalf("Unexpected call to TokenRepositoryMock.ValidateRefreshToken. %v", tokenString)
	return
}

// ValidateRefreshTokenAfterCounter returns a count of finished TokenRepositoryMock.ValidateRefreshToken invocations
func (mmValidateRefreshToken *TokenRepositoryMock) ValidateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateRefreshToken.afterValidateRefreshTokenCounter)
}

// ValidateRefreshTokenBeforeCounter returns a count of TokenRepositoryMock.ValidateRefreshToken invocations
func (mmValidateRefreshToken *TokenRepositoryMock) ValidateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateRefreshToken.beforeValidateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepositoryMock.ValidateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateRefreshToken *mTokenRepositoryMockValidateRefreshToken) Calls() []*TokenRepositoryMockValidateRefreshTokenParams {
	mmValidateRefreshToken.mutex.RLock()

	argCopy := make([]*TokenRepositoryMockValidateRefreshTokenParams, len(mmValidateRefreshToken.callArgs))
	copy(argCopy, mmValidateRefreshToken.callArgs)

	mmValidateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockValidateRefreshTokenDone returns true if the count of the ValidateRefreshToken invocations corresponds
// the number of defined expectations
func (m *TokenRepositoryMock) MinimockValidateRefreshTokenDone() bool {
	if m.ValidateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateRefreshTokenMock.invocationsDone()
}

// MinimockValidateRefreshTokenInspect logs each unmet expectation
func (m *TokenRepositoryMock) MinimockValidateRefreshTokenInspect() {
	for _, e := range m.ValidateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterValidateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateRefreshTokenMock.defaultExpectation != nil && afterValidateRefreshTokenCounter < 1 {
		if m.ValidateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateRefreshToken at\n%s", m.ValidateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TokenRepositoryMock.ValidateRefreshToken at\n%s with params: %#v", m.ValidateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.ValidateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateRefreshToken != nil && afterValidateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to TokenRepositoryMock.ValidateRefreshToken at\n%s", m.funcValidateRefreshTokenOrigin)
	}

	if !m.ValidateRefreshTokenMock.invocationsDone() && afterValidateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to TokenRepositoryMock.ValidateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateRefreshTokenMock.expectedInvocations), m.ValidateRefreshTokenMock.expectedInvocationsOrigin, afterValidateRefreshTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TokenRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccessTokenInspect()

			m.MinimockCreateRefreshTokenInspect()

			m.MinimockValidateAccessTokenInspect()

			m.MinimockValidateRefreshTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TokenRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TokenRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccessTokenDone() &&
		m.MinimockCreateRefreshTokenDone() &&
		m.MinimockValidateAccessTokenDone() &&
		m.MinimockValidateRefreshTokenDone()
}
