// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/lameroot/msa-messenger/internal/auth/usecase.PersistentRepository -o persistent_repository_mock.go -n PersistentRepositoryMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	auth_models "github.com/lameroot/msa-messenger/internal/auth/models"
)

// PersistentRepositoryMock implements mm_auth_usecase.PersistentRepository
type PersistentRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetUserByEmail          func(email string) (up1 *auth_models.User, err error)
	funcGetUserByEmailOrigin    string
	inspectFuncGetUserByEmail   func(email string)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mPersistentRepositoryMockGetUserByEmail

	funcGetUserByID          func(id uuid.UUID) (up1 *auth_models.User, err error)
	funcGetUserByIDOrigin    string
	inspectFuncGetUserByID   func(id uuid.UUID)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mPersistentRepositoryMockGetUserByID

	funcGetUserByNickname          func(nickname string) (up1 *auth_models.User, err error)
	funcGetUserByNicknameOrigin    string
	inspectFuncGetUserByNickname   func(nickname string)
	afterGetUserByNicknameCounter  uint64
	beforeGetUserByNicknameCounter uint64
	GetUserByNicknameMock          mPersistentRepositoryMockGetUserByNickname

	funcSaveUser          func(user *auth_models.User) (up1 *auth_models.User, err error)
	funcSaveUserOrigin    string
	inspectFuncSaveUser   func(user *auth_models.User)
	afterSaveUserCounter  uint64
	beforeSaveUserCounter uint64
	SaveUserMock          mPersistentRepositoryMockSaveUser

	funcUpdateUser          func(id uuid.UUID, avatart_url string, info string) (up1 *auth_models.User, err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(id uuid.UUID, avatart_url string, info string)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mPersistentRepositoryMockUpdateUser
}

// NewPersistentRepositoryMock returns a mock for mm_auth_usecase.PersistentRepository
func NewPersistentRepositoryMock(t minimock.Tester) *PersistentRepositoryMock {
	m := &PersistentRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserByEmailMock = mPersistentRepositoryMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*PersistentRepositoryMockGetUserByEmailParams{}

	m.GetUserByIDMock = mPersistentRepositoryMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*PersistentRepositoryMockGetUserByIDParams{}

	m.GetUserByNicknameMock = mPersistentRepositoryMockGetUserByNickname{mock: m}
	m.GetUserByNicknameMock.callArgs = []*PersistentRepositoryMockGetUserByNicknameParams{}

	m.SaveUserMock = mPersistentRepositoryMockSaveUser{mock: m}
	m.SaveUserMock.callArgs = []*PersistentRepositoryMockSaveUserParams{}

	m.UpdateUserMock = mPersistentRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*PersistentRepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPersistentRepositoryMockGetUserByEmail struct {
	optional           bool
	mock               *PersistentRepositoryMock
	defaultExpectation *PersistentRepositoryMockGetUserByEmailExpectation
	expectations       []*PersistentRepositoryMockGetUserByEmailExpectation

	callArgs []*PersistentRepositoryMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersistentRepositoryMockGetUserByEmailExpectation specifies expectation struct of the PersistentRepository.GetUserByEmail
type PersistentRepositoryMockGetUserByEmailExpectation struct {
	mock               *PersistentRepositoryMock
	params             *PersistentRepositoryMockGetUserByEmailParams
	paramPtrs          *PersistentRepositoryMockGetUserByEmailParamPtrs
	expectationOrigins PersistentRepositoryMockGetUserByEmailExpectationOrigins
	results            *PersistentRepositoryMockGetUserByEmailResults
	returnOrigin       string
	Counter            uint64
}

// PersistentRepositoryMockGetUserByEmailParams contains parameters of the PersistentRepository.GetUserByEmail
type PersistentRepositoryMockGetUserByEmailParams struct {
	email string
}

// PersistentRepositoryMockGetUserByEmailParamPtrs contains pointers to parameters of the PersistentRepository.GetUserByEmail
type PersistentRepositoryMockGetUserByEmailParamPtrs struct {
	email *string
}

// PersistentRepositoryMockGetUserByEmailResults contains results of the PersistentRepository.GetUserByEmail
type PersistentRepositoryMockGetUserByEmailResults struct {
	up1 *auth_models.User
	err error
}

// PersistentRepositoryMockGetUserByEmailOrigins contains origins of expectations of the PersistentRepository.GetUserByEmail
type PersistentRepositoryMockGetUserByEmailExpectationOrigins struct {
	origin      string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Optional() *mPersistentRepositoryMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for PersistentRepository.GetUserByEmail
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Expect(email string) *mPersistentRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &PersistentRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &PersistentRepositoryMockGetUserByEmailParams{email}
	mmGetUserByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectEmailParam1 sets up expected param email for PersistentRepository.GetUserByEmail
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) ExpectEmailParam1(email string) *mPersistentRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &PersistentRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &PersistentRepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the PersistentRepository.GetUserByEmail
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Inspect(f func(email string)) *mPersistentRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for PersistentRepositoryMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by PersistentRepository.GetUserByEmail
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Return(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &PersistentRepositoryMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &PersistentRepositoryMockGetUserByEmailResults{up1, err}
	mmGetUserByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the PersistentRepository.GetUserByEmail method
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Set(f func(email string) (up1 *auth_models.User, err error)) *PersistentRepositoryMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the PersistentRepository.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the PersistentRepository.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	mmGetUserByEmail.mock.funcGetUserByEmailOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// When sets expectation for the PersistentRepository.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) When(email string) *PersistentRepositoryMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("PersistentRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &PersistentRepositoryMockGetUserByEmailExpectation{
		mock:               mmGetUserByEmail.mock,
		params:             &PersistentRepositoryMockGetUserByEmailParams{email},
		expectationOrigins: PersistentRepositoryMockGetUserByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up PersistentRepository.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *PersistentRepositoryMockGetUserByEmailExpectation) Then(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	e.results = &PersistentRepositoryMockGetUserByEmailResults{up1, err}
	return e.mock
}

// Times sets number of times PersistentRepository.GetUserByEmail should be invoked
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Times(n uint64) *mPersistentRepositoryMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of PersistentRepositoryMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	mmGetUserByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements mm_auth_usecase.PersistentRepository
func (mmGetUserByEmail *PersistentRepositoryMock) GetUserByEmail(email string) (up1 *auth_models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	mmGetUserByEmail.t.Helper()

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(email)
	}

	mm_params := PersistentRepositoryMockGetUserByEmailParams{email}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := PersistentRepositoryMockGetUserByEmailParams{email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetUserByEmail.t.Errorf("PersistentRepositoryMock.GetUserByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("PersistentRepositoryMock.GetUserByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the PersistentRepositoryMock.GetUserByEmail")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(email)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to PersistentRepositoryMock.GetUserByEmail. %v", email)
	return
}

// GetUserByEmailAfterCounter returns a count of finished PersistentRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *PersistentRepositoryMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of PersistentRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *PersistentRepositoryMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to PersistentRepositoryMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mPersistentRepositoryMockGetUserByEmail) Calls() []*PersistentRepositoryMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*PersistentRepositoryMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *PersistentRepositoryMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *PersistentRepositoryMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByEmail at\n%s", m.GetUserByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByEmail at\n%s with params: %#v", m.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByEmail at\n%s", m.funcGetUserByEmailOrigin)
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to PersistentRepositoryMock.GetUserByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), m.GetUserByEmailMock.expectedInvocationsOrigin, afterGetUserByEmailCounter)
	}
}

type mPersistentRepositoryMockGetUserByID struct {
	optional           bool
	mock               *PersistentRepositoryMock
	defaultExpectation *PersistentRepositoryMockGetUserByIDExpectation
	expectations       []*PersistentRepositoryMockGetUserByIDExpectation

	callArgs []*PersistentRepositoryMockGetUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersistentRepositoryMockGetUserByIDExpectation specifies expectation struct of the PersistentRepository.GetUserByID
type PersistentRepositoryMockGetUserByIDExpectation struct {
	mock               *PersistentRepositoryMock
	params             *PersistentRepositoryMockGetUserByIDParams
	paramPtrs          *PersistentRepositoryMockGetUserByIDParamPtrs
	expectationOrigins PersistentRepositoryMockGetUserByIDExpectationOrigins
	results            *PersistentRepositoryMockGetUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// PersistentRepositoryMockGetUserByIDParams contains parameters of the PersistentRepository.GetUserByID
type PersistentRepositoryMockGetUserByIDParams struct {
	id uuid.UUID
}

// PersistentRepositoryMockGetUserByIDParamPtrs contains pointers to parameters of the PersistentRepository.GetUserByID
type PersistentRepositoryMockGetUserByIDParamPtrs struct {
	id *uuid.UUID
}

// PersistentRepositoryMockGetUserByIDResults contains results of the PersistentRepository.GetUserByID
type PersistentRepositoryMockGetUserByIDResults struct {
	up1 *auth_models.User
	err error
}

// PersistentRepositoryMockGetUserByIDOrigins contains origins of expectations of the PersistentRepository.GetUserByID
type PersistentRepositoryMockGetUserByIDExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Optional() *mPersistentRepositoryMockGetUserByID {
	mmGetUserByID.optional = true
	return mmGetUserByID
}

// Expect sets up expected params for PersistentRepository.GetUserByID
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Expect(id uuid.UUID) *mPersistentRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &PersistentRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.paramPtrs != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by ExpectParams functions")
	}

	mmGetUserByID.defaultExpectation.params = &PersistentRepositoryMockGetUserByIDParams{id}
	mmGetUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// ExpectIdParam1 sets up expected param id for PersistentRepository.GetUserByID
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) ExpectIdParam1(id uuid.UUID) *mPersistentRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &PersistentRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &PersistentRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.id = &id
	mmGetUserByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the PersistentRepository.GetUserByID
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Inspect(f func(id uuid.UUID)) *mPersistentRepositoryMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for PersistentRepositoryMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by PersistentRepository.GetUserByID
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Return(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &PersistentRepositoryMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &PersistentRepositoryMockGetUserByIDResults{up1, err}
	mmGetUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// Set uses given function f to mock the PersistentRepository.GetUserByID method
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Set(f func(id uuid.UUID) (up1 *auth_models.User, err error)) *PersistentRepositoryMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the PersistentRepository.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the PersistentRepository.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	mmGetUserByID.mock.funcGetUserByIDOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// When sets expectation for the PersistentRepository.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) When(id uuid.UUID) *PersistentRepositoryMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("PersistentRepositoryMock.GetUserByID mock is already set by Set")
	}

	expectation := &PersistentRepositoryMockGetUserByIDExpectation{
		mock:               mmGetUserByID.mock,
		params:             &PersistentRepositoryMockGetUserByIDParams{id},
		expectationOrigins: PersistentRepositoryMockGetUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up PersistentRepository.GetUserByID return parameters for the expectation previously defined by the When method
func (e *PersistentRepositoryMockGetUserByIDExpectation) Then(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	e.results = &PersistentRepositoryMockGetUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times PersistentRepository.GetUserByID should be invoked
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Times(n uint64) *mPersistentRepositoryMockGetUserByID {
	if n == 0 {
		mmGetUserByID.mock.t.Fatalf("Times of PersistentRepositoryMock.GetUserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByID.expectedInvocations, n)
	mmGetUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByID
}

func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) invocationsDone() bool {
	if len(mmGetUserByID.expectations) == 0 && mmGetUserByID.defaultExpectation == nil && mmGetUserByID.mock.funcGetUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByID.mock.afterGetUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByID implements mm_auth_usecase.PersistentRepository
func (mmGetUserByID *PersistentRepositoryMock) GetUserByID(id uuid.UUID) (up1 *auth_models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	mmGetUserByID.t.Helper()

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(id)
	}

	mm_params := PersistentRepositoryMockGetUserByIDParams{id}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, &mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByID.GetUserByIDMock.defaultExpectation.paramPtrs

		mm_got := PersistentRepositoryMockGetUserByIDParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUserByID.t.Errorf("PersistentRepositoryMock.GetUserByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("PersistentRepositoryMock.GetUserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the PersistentRepositoryMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(id)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to PersistentRepositoryMock.GetUserByID. %v", id)
	return
}

// GetUserByIDAfterCounter returns a count of finished PersistentRepositoryMock.GetUserByID invocations
func (mmGetUserByID *PersistentRepositoryMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of PersistentRepositoryMock.GetUserByID invocations
func (mmGetUserByID *PersistentRepositoryMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to PersistentRepositoryMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mPersistentRepositoryMockGetUserByID) Calls() []*PersistentRepositoryMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*PersistentRepositoryMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *PersistentRepositoryMock) MinimockGetUserByIDDone() bool {
	if m.GetUserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByIDMock.invocationsDone()
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *PersistentRepositoryMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByIDCounter := mm_atomic.LoadUint64(&m.afterGetUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && afterGetUserByIDCounter < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByID at\n%s", m.GetUserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByID at\n%s with params: %#v", m.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && afterGetUserByIDCounter < 1 {
		m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByID at\n%s", m.funcGetUserByIDOrigin)
	}

	if !m.GetUserByIDMock.invocationsDone() && afterGetUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PersistentRepositoryMock.GetUserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByIDMock.expectedInvocations), m.GetUserByIDMock.expectedInvocationsOrigin, afterGetUserByIDCounter)
	}
}

type mPersistentRepositoryMockGetUserByNickname struct {
	optional           bool
	mock               *PersistentRepositoryMock
	defaultExpectation *PersistentRepositoryMockGetUserByNicknameExpectation
	expectations       []*PersistentRepositoryMockGetUserByNicknameExpectation

	callArgs []*PersistentRepositoryMockGetUserByNicknameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersistentRepositoryMockGetUserByNicknameExpectation specifies expectation struct of the PersistentRepository.GetUserByNickname
type PersistentRepositoryMockGetUserByNicknameExpectation struct {
	mock               *PersistentRepositoryMock
	params             *PersistentRepositoryMockGetUserByNicknameParams
	paramPtrs          *PersistentRepositoryMockGetUserByNicknameParamPtrs
	expectationOrigins PersistentRepositoryMockGetUserByNicknameExpectationOrigins
	results            *PersistentRepositoryMockGetUserByNicknameResults
	returnOrigin       string
	Counter            uint64
}

// PersistentRepositoryMockGetUserByNicknameParams contains parameters of the PersistentRepository.GetUserByNickname
type PersistentRepositoryMockGetUserByNicknameParams struct {
	nickname string
}

// PersistentRepositoryMockGetUserByNicknameParamPtrs contains pointers to parameters of the PersistentRepository.GetUserByNickname
type PersistentRepositoryMockGetUserByNicknameParamPtrs struct {
	nickname *string
}

// PersistentRepositoryMockGetUserByNicknameResults contains results of the PersistentRepository.GetUserByNickname
type PersistentRepositoryMockGetUserByNicknameResults struct {
	up1 *auth_models.User
	err error
}

// PersistentRepositoryMockGetUserByNicknameOrigins contains origins of expectations of the PersistentRepository.GetUserByNickname
type PersistentRepositoryMockGetUserByNicknameExpectationOrigins struct {
	origin         string
	originNickname string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Optional() *mPersistentRepositoryMockGetUserByNickname {
	mmGetUserByNickname.optional = true
	return mmGetUserByNickname
}

// Expect sets up expected params for PersistentRepository.GetUserByNickname
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Expect(nickname string) *mPersistentRepositoryMockGetUserByNickname {
	if mmGetUserByNickname.mock.funcGetUserByNickname != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by Set")
	}

	if mmGetUserByNickname.defaultExpectation == nil {
		mmGetUserByNickname.defaultExpectation = &PersistentRepositoryMockGetUserByNicknameExpectation{}
	}

	if mmGetUserByNickname.defaultExpectation.paramPtrs != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by ExpectParams functions")
	}

	mmGetUserByNickname.defaultExpectation.params = &PersistentRepositoryMockGetUserByNicknameParams{nickname}
	mmGetUserByNickname.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByNickname.expectations {
		if minimock.Equal(e.params, mmGetUserByNickname.defaultExpectation.params) {
			mmGetUserByNickname.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByNickname.defaultExpectation.params)
		}
	}

	return mmGetUserByNickname
}

// ExpectNicknameParam1 sets up expected param nickname for PersistentRepository.GetUserByNickname
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) ExpectNicknameParam1(nickname string) *mPersistentRepositoryMockGetUserByNickname {
	if mmGetUserByNickname.mock.funcGetUserByNickname != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by Set")
	}

	if mmGetUserByNickname.defaultExpectation == nil {
		mmGetUserByNickname.defaultExpectation = &PersistentRepositoryMockGetUserByNicknameExpectation{}
	}

	if mmGetUserByNickname.defaultExpectation.params != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by Expect")
	}

	if mmGetUserByNickname.defaultExpectation.paramPtrs == nil {
		mmGetUserByNickname.defaultExpectation.paramPtrs = &PersistentRepositoryMockGetUserByNicknameParamPtrs{}
	}
	mmGetUserByNickname.defaultExpectation.paramPtrs.nickname = &nickname
	mmGetUserByNickname.defaultExpectation.expectationOrigins.originNickname = minimock.CallerInfo(1)

	return mmGetUserByNickname
}

// Inspect accepts an inspector function that has same arguments as the PersistentRepository.GetUserByNickname
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Inspect(f func(nickname string)) *mPersistentRepositoryMockGetUserByNickname {
	if mmGetUserByNickname.mock.inspectFuncGetUserByNickname != nil {
		mmGetUserByNickname.mock.t.Fatalf("Inspect function is already set for PersistentRepositoryMock.GetUserByNickname")
	}

	mmGetUserByNickname.mock.inspectFuncGetUserByNickname = f

	return mmGetUserByNickname
}

// Return sets up results that will be returned by PersistentRepository.GetUserByNickname
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Return(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	if mmGetUserByNickname.mock.funcGetUserByNickname != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by Set")
	}

	if mmGetUserByNickname.defaultExpectation == nil {
		mmGetUserByNickname.defaultExpectation = &PersistentRepositoryMockGetUserByNicknameExpectation{mock: mmGetUserByNickname.mock}
	}
	mmGetUserByNickname.defaultExpectation.results = &PersistentRepositoryMockGetUserByNicknameResults{up1, err}
	mmGetUserByNickname.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByNickname.mock
}

// Set uses given function f to mock the PersistentRepository.GetUserByNickname method
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Set(f func(nickname string) (up1 *auth_models.User, err error)) *PersistentRepositoryMock {
	if mmGetUserByNickname.defaultExpectation != nil {
		mmGetUserByNickname.mock.t.Fatalf("Default expectation is already set for the PersistentRepository.GetUserByNickname method")
	}

	if len(mmGetUserByNickname.expectations) > 0 {
		mmGetUserByNickname.mock.t.Fatalf("Some expectations are already set for the PersistentRepository.GetUserByNickname method")
	}

	mmGetUserByNickname.mock.funcGetUserByNickname = f
	mmGetUserByNickname.mock.funcGetUserByNicknameOrigin = minimock.CallerInfo(1)
	return mmGetUserByNickname.mock
}

// When sets expectation for the PersistentRepository.GetUserByNickname which will trigger the result defined by the following
// Then helper
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) When(nickname string) *PersistentRepositoryMockGetUserByNicknameExpectation {
	if mmGetUserByNickname.mock.funcGetUserByNickname != nil {
		mmGetUserByNickname.mock.t.Fatalf("PersistentRepositoryMock.GetUserByNickname mock is already set by Set")
	}

	expectation := &PersistentRepositoryMockGetUserByNicknameExpectation{
		mock:               mmGetUserByNickname.mock,
		params:             &PersistentRepositoryMockGetUserByNicknameParams{nickname},
		expectationOrigins: PersistentRepositoryMockGetUserByNicknameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByNickname.expectations = append(mmGetUserByNickname.expectations, expectation)
	return expectation
}

// Then sets up PersistentRepository.GetUserByNickname return parameters for the expectation previously defined by the When method
func (e *PersistentRepositoryMockGetUserByNicknameExpectation) Then(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	e.results = &PersistentRepositoryMockGetUserByNicknameResults{up1, err}
	return e.mock
}

// Times sets number of times PersistentRepository.GetUserByNickname should be invoked
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Times(n uint64) *mPersistentRepositoryMockGetUserByNickname {
	if n == 0 {
		mmGetUserByNickname.mock.t.Fatalf("Times of PersistentRepositoryMock.GetUserByNickname mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByNickname.expectedInvocations, n)
	mmGetUserByNickname.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByNickname
}

func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) invocationsDone() bool {
	if len(mmGetUserByNickname.expectations) == 0 && mmGetUserByNickname.defaultExpectation == nil && mmGetUserByNickname.mock.funcGetUserByNickname == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByNickname.mock.afterGetUserByNicknameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByNickname.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByNickname implements mm_auth_usecase.PersistentRepository
func (mmGetUserByNickname *PersistentRepositoryMock) GetUserByNickname(nickname string) (up1 *auth_models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByNickname.beforeGetUserByNicknameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByNickname.afterGetUserByNicknameCounter, 1)

	mmGetUserByNickname.t.Helper()

	if mmGetUserByNickname.inspectFuncGetUserByNickname != nil {
		mmGetUserByNickname.inspectFuncGetUserByNickname(nickname)
	}

	mm_params := PersistentRepositoryMockGetUserByNicknameParams{nickname}

	// Record call args
	mmGetUserByNickname.GetUserByNicknameMock.mutex.Lock()
	mmGetUserByNickname.GetUserByNicknameMock.callArgs = append(mmGetUserByNickname.GetUserByNicknameMock.callArgs, &mm_params)
	mmGetUserByNickname.GetUserByNicknameMock.mutex.Unlock()

	for _, e := range mmGetUserByNickname.GetUserByNicknameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.paramPtrs

		mm_got := PersistentRepositoryMockGetUserByNicknameParams{nickname}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.nickname != nil && !minimock.Equal(*mm_want_ptrs.nickname, mm_got.nickname) {
				mmGetUserByNickname.t.Errorf("PersistentRepositoryMock.GetUserByNickname got unexpected parameter nickname, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.expectationOrigins.originNickname, *mm_want_ptrs.nickname, mm_got.nickname, minimock.Diff(*mm_want_ptrs.nickname, mm_got.nickname))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByNickname.t.Errorf("PersistentRepositoryMock.GetUserByNickname got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByNickname.GetUserByNicknameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByNickname.t.Fatal("No results are set for the PersistentRepositoryMock.GetUserByNickname")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByNickname.funcGetUserByNickname != nil {
		return mmGetUserByNickname.funcGetUserByNickname(nickname)
	}
	mmGetUserByNickname.t.Fatalf("Unexpected call to PersistentRepositoryMock.GetUserByNickname. %v", nickname)
	return
}

// GetUserByNicknameAfterCounter returns a count of finished PersistentRepositoryMock.GetUserByNickname invocations
func (mmGetUserByNickname *PersistentRepositoryMock) GetUserByNicknameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByNickname.afterGetUserByNicknameCounter)
}

// GetUserByNicknameBeforeCounter returns a count of PersistentRepositoryMock.GetUserByNickname invocations
func (mmGetUserByNickname *PersistentRepositoryMock) GetUserByNicknameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByNickname.beforeGetUserByNicknameCounter)
}

// Calls returns a list of arguments used in each call to PersistentRepositoryMock.GetUserByNickname.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByNickname *mPersistentRepositoryMockGetUserByNickname) Calls() []*PersistentRepositoryMockGetUserByNicknameParams {
	mmGetUserByNickname.mutex.RLock()

	argCopy := make([]*PersistentRepositoryMockGetUserByNicknameParams, len(mmGetUserByNickname.callArgs))
	copy(argCopy, mmGetUserByNickname.callArgs)

	mmGetUserByNickname.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByNicknameDone returns true if the count of the GetUserByNickname invocations corresponds
// the number of defined expectations
func (m *PersistentRepositoryMock) MinimockGetUserByNicknameDone() bool {
	if m.GetUserByNicknameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByNicknameMock.invocationsDone()
}

// MinimockGetUserByNicknameInspect logs each unmet expectation
func (m *PersistentRepositoryMock) MinimockGetUserByNicknameInspect() {
	for _, e := range m.GetUserByNicknameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByNickname at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByNicknameCounter := mm_atomic.LoadUint64(&m.afterGetUserByNicknameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByNicknameMock.defaultExpectation != nil && afterGetUserByNicknameCounter < 1 {
		if m.GetUserByNicknameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByNickname at\n%s", m.GetUserByNicknameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByNickname at\n%s with params: %#v", m.GetUserByNicknameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByNicknameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByNickname != nil && afterGetUserByNicknameCounter < 1 {
		m.t.Errorf("Expected call to PersistentRepositoryMock.GetUserByNickname at\n%s", m.funcGetUserByNicknameOrigin)
	}

	if !m.GetUserByNicknameMock.invocationsDone() && afterGetUserByNicknameCounter > 0 {
		m.t.Errorf("Expected %d calls to PersistentRepositoryMock.GetUserByNickname at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByNicknameMock.expectedInvocations), m.GetUserByNicknameMock.expectedInvocationsOrigin, afterGetUserByNicknameCounter)
	}
}

type mPersistentRepositoryMockSaveUser struct {
	optional           bool
	mock               *PersistentRepositoryMock
	defaultExpectation *PersistentRepositoryMockSaveUserExpectation
	expectations       []*PersistentRepositoryMockSaveUserExpectation

	callArgs []*PersistentRepositoryMockSaveUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersistentRepositoryMockSaveUserExpectation specifies expectation struct of the PersistentRepository.SaveUser
type PersistentRepositoryMockSaveUserExpectation struct {
	mock               *PersistentRepositoryMock
	params             *PersistentRepositoryMockSaveUserParams
	paramPtrs          *PersistentRepositoryMockSaveUserParamPtrs
	expectationOrigins PersistentRepositoryMockSaveUserExpectationOrigins
	results            *PersistentRepositoryMockSaveUserResults
	returnOrigin       string
	Counter            uint64
}

// PersistentRepositoryMockSaveUserParams contains parameters of the PersistentRepository.SaveUser
type PersistentRepositoryMockSaveUserParams struct {
	user *auth_models.User
}

// PersistentRepositoryMockSaveUserParamPtrs contains pointers to parameters of the PersistentRepository.SaveUser
type PersistentRepositoryMockSaveUserParamPtrs struct {
	user **auth_models.User
}

// PersistentRepositoryMockSaveUserResults contains results of the PersistentRepository.SaveUser
type PersistentRepositoryMockSaveUserResults struct {
	up1 *auth_models.User
	err error
}

// PersistentRepositoryMockSaveUserOrigins contains origins of expectations of the PersistentRepository.SaveUser
type PersistentRepositoryMockSaveUserExpectationOrigins struct {
	origin     string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Optional() *mPersistentRepositoryMockSaveUser {
	mmSaveUser.optional = true
	return mmSaveUser
}

// Expect sets up expected params for PersistentRepository.SaveUser
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Expect(user *auth_models.User) *mPersistentRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &PersistentRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.paramPtrs != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by ExpectParams functions")
	}

	mmSaveUser.defaultExpectation.params = &PersistentRepositoryMockSaveUserParams{user}
	mmSaveUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveUser.expectations {
		if minimock.Equal(e.params, mmSaveUser.defaultExpectation.params) {
			mmSaveUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUser.defaultExpectation.params)
		}
	}

	return mmSaveUser
}

// ExpectUserParam1 sets up expected param user for PersistentRepository.SaveUser
func (mmSaveUser *mPersistentRepositoryMockSaveUser) ExpectUserParam1(user *auth_models.User) *mPersistentRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &PersistentRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.params != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by Expect")
	}

	if mmSaveUser.defaultExpectation.paramPtrs == nil {
		mmSaveUser.defaultExpectation.paramPtrs = &PersistentRepositoryMockSaveUserParamPtrs{}
	}
	mmSaveUser.defaultExpectation.paramPtrs.user = &user
	mmSaveUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSaveUser
}

// Inspect accepts an inspector function that has same arguments as the PersistentRepository.SaveUser
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Inspect(f func(user *auth_models.User)) *mPersistentRepositoryMockSaveUser {
	if mmSaveUser.mock.inspectFuncSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("Inspect function is already set for PersistentRepositoryMock.SaveUser")
	}

	mmSaveUser.mock.inspectFuncSaveUser = f

	return mmSaveUser
}

// Return sets up results that will be returned by PersistentRepository.SaveUser
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Return(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &PersistentRepositoryMockSaveUserExpectation{mock: mmSaveUser.mock}
	}
	mmSaveUser.defaultExpectation.results = &PersistentRepositoryMockSaveUserResults{up1, err}
	mmSaveUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveUser.mock
}

// Set uses given function f to mock the PersistentRepository.SaveUser method
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Set(f func(user *auth_models.User) (up1 *auth_models.User, err error)) *PersistentRepositoryMock {
	if mmSaveUser.defaultExpectation != nil {
		mmSaveUser.mock.t.Fatalf("Default expectation is already set for the PersistentRepository.SaveUser method")
	}

	if len(mmSaveUser.expectations) > 0 {
		mmSaveUser.mock.t.Fatalf("Some expectations are already set for the PersistentRepository.SaveUser method")
	}

	mmSaveUser.mock.funcSaveUser = f
	mmSaveUser.mock.funcSaveUserOrigin = minimock.CallerInfo(1)
	return mmSaveUser.mock
}

// When sets expectation for the PersistentRepository.SaveUser which will trigger the result defined by the following
// Then helper
func (mmSaveUser *mPersistentRepositoryMockSaveUser) When(user *auth_models.User) *PersistentRepositoryMockSaveUserExpectation {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("PersistentRepositoryMock.SaveUser mock is already set by Set")
	}

	expectation := &PersistentRepositoryMockSaveUserExpectation{
		mock:               mmSaveUser.mock,
		params:             &PersistentRepositoryMockSaveUserParams{user},
		expectationOrigins: PersistentRepositoryMockSaveUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveUser.expectations = append(mmSaveUser.expectations, expectation)
	return expectation
}

// Then sets up PersistentRepository.SaveUser return parameters for the expectation previously defined by the When method
func (e *PersistentRepositoryMockSaveUserExpectation) Then(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	e.results = &PersistentRepositoryMockSaveUserResults{up1, err}
	return e.mock
}

// Times sets number of times PersistentRepository.SaveUser should be invoked
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Times(n uint64) *mPersistentRepositoryMockSaveUser {
	if n == 0 {
		mmSaveUser.mock.t.Fatalf("Times of PersistentRepositoryMock.SaveUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveUser.expectedInvocations, n)
	mmSaveUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveUser
}

func (mmSaveUser *mPersistentRepositoryMockSaveUser) invocationsDone() bool {
	if len(mmSaveUser.expectations) == 0 && mmSaveUser.defaultExpectation == nil && mmSaveUser.mock.funcSaveUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveUser.mock.afterSaveUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveUser implements mm_auth_usecase.PersistentRepository
func (mmSaveUser *PersistentRepositoryMock) SaveUser(user *auth_models.User) (up1 *auth_models.User, err error) {
	mm_atomic.AddUint64(&mmSaveUser.beforeSaveUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUser.afterSaveUserCounter, 1)

	mmSaveUser.t.Helper()

	if mmSaveUser.inspectFuncSaveUser != nil {
		mmSaveUser.inspectFuncSaveUser(user)
	}

	mm_params := PersistentRepositoryMockSaveUserParams{user}

	// Record call args
	mmSaveUser.SaveUserMock.mutex.Lock()
	mmSaveUser.SaveUserMock.callArgs = append(mmSaveUser.SaveUserMock.callArgs, &mm_params)
	mmSaveUser.SaveUserMock.mutex.Unlock()

	for _, e := range mmSaveUser.SaveUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmSaveUser.SaveUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUser.SaveUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUser.SaveUserMock.defaultExpectation.params
		mm_want_ptrs := mmSaveUser.SaveUserMock.defaultExpectation.paramPtrs

		mm_got := PersistentRepositoryMockSaveUserParams{user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSaveUser.t.Errorf("PersistentRepositoryMock.SaveUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUser.t.Errorf("PersistentRepositoryMock.SaveUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUser.SaveUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUser.t.Fatal("No results are set for the PersistentRepositoryMock.SaveUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmSaveUser.funcSaveUser != nil {
		return mmSaveUser.funcSaveUser(user)
	}
	mmSaveUser.t.Fatalf("Unexpected call to PersistentRepositoryMock.SaveUser. %v", user)
	return
}

// SaveUserAfterCounter returns a count of finished PersistentRepositoryMock.SaveUser invocations
func (mmSaveUser *PersistentRepositoryMock) SaveUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.afterSaveUserCounter)
}

// SaveUserBeforeCounter returns a count of PersistentRepositoryMock.SaveUser invocations
func (mmSaveUser *PersistentRepositoryMock) SaveUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.beforeSaveUserCounter)
}

// Calls returns a list of arguments used in each call to PersistentRepositoryMock.SaveUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUser *mPersistentRepositoryMockSaveUser) Calls() []*PersistentRepositoryMockSaveUserParams {
	mmSaveUser.mutex.RLock()

	argCopy := make([]*PersistentRepositoryMockSaveUserParams, len(mmSaveUser.callArgs))
	copy(argCopy, mmSaveUser.callArgs)

	mmSaveUser.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserDone returns true if the count of the SaveUser invocations corresponds
// the number of defined expectations
func (m *PersistentRepositoryMock) MinimockSaveUserDone() bool {
	if m.SaveUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveUserMock.invocationsDone()
}

// MinimockSaveUserInspect logs each unmet expectation
func (m *PersistentRepositoryMock) MinimockSaveUserInspect() {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentRepositoryMock.SaveUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveUserCounter := mm_atomic.LoadUint64(&m.afterSaveUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && afterSaveUserCounter < 1 {
		if m.SaveUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersistentRepositoryMock.SaveUser at\n%s", m.SaveUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersistentRepositoryMock.SaveUser at\n%s with params: %#v", m.SaveUserMock.defaultExpectation.expectationOrigins.origin, *m.SaveUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && afterSaveUserCounter < 1 {
		m.t.Errorf("Expected call to PersistentRepositoryMock.SaveUser at\n%s", m.funcSaveUserOrigin)
	}

	if !m.SaveUserMock.invocationsDone() && afterSaveUserCounter > 0 {
		m.t.Errorf("Expected %d calls to PersistentRepositoryMock.SaveUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveUserMock.expectedInvocations), m.SaveUserMock.expectedInvocationsOrigin, afterSaveUserCounter)
	}
}

type mPersistentRepositoryMockUpdateUser struct {
	optional           bool
	mock               *PersistentRepositoryMock
	defaultExpectation *PersistentRepositoryMockUpdateUserExpectation
	expectations       []*PersistentRepositoryMockUpdateUserExpectation

	callArgs []*PersistentRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersistentRepositoryMockUpdateUserExpectation specifies expectation struct of the PersistentRepository.UpdateUser
type PersistentRepositoryMockUpdateUserExpectation struct {
	mock               *PersistentRepositoryMock
	params             *PersistentRepositoryMockUpdateUserParams
	paramPtrs          *PersistentRepositoryMockUpdateUserParamPtrs
	expectationOrigins PersistentRepositoryMockUpdateUserExpectationOrigins
	results            *PersistentRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// PersistentRepositoryMockUpdateUserParams contains parameters of the PersistentRepository.UpdateUser
type PersistentRepositoryMockUpdateUserParams struct {
	id          uuid.UUID
	avatart_url string
	info        string
}

// PersistentRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the PersistentRepository.UpdateUser
type PersistentRepositoryMockUpdateUserParamPtrs struct {
	id          *uuid.UUID
	avatart_url *string
	info        *string
}

// PersistentRepositoryMockUpdateUserResults contains results of the PersistentRepository.UpdateUser
type PersistentRepositoryMockUpdateUserResults struct {
	up1 *auth_models.User
	err error
}

// PersistentRepositoryMockUpdateUserOrigins contains origins of expectations of the PersistentRepository.UpdateUser
type PersistentRepositoryMockUpdateUserExpectationOrigins struct {
	origin            string
	originId          string
	originAvatart_url string
	originInfo        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Optional() *mPersistentRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Expect(id uuid.UUID, avatart_url string, info string) *mPersistentRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &PersistentRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &PersistentRepositoryMockUpdateUserParams{id, avatart_url, info}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectIdParam1 sets up expected param id for PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) ExpectIdParam1(id uuid.UUID) *mPersistentRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &PersistentRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &PersistentRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.id = &id
	mmUpdateUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectAvatart_urlParam2 sets up expected param avatart_url for PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) ExpectAvatart_urlParam2(avatart_url string) *mPersistentRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &PersistentRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &PersistentRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.avatart_url = &avatart_url
	mmUpdateUser.defaultExpectation.expectationOrigins.originAvatart_url = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectInfoParam3 sets up expected param info for PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) ExpectInfoParam3(info string) *mPersistentRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &PersistentRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &PersistentRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.info = &info
	mmUpdateUser.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Inspect(f func(id uuid.UUID, avatart_url string, info string)) *mPersistentRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for PersistentRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by PersistentRepository.UpdateUser
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Return(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &PersistentRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &PersistentRepositoryMockUpdateUserResults{up1, err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the PersistentRepository.UpdateUser method
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Set(f func(id uuid.UUID, avatart_url string, info string) (up1 *auth_models.User, err error)) *PersistentRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the PersistentRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the PersistentRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the PersistentRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) When(id uuid.UUID, avatart_url string, info string) *PersistentRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("PersistentRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &PersistentRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &PersistentRepositoryMockUpdateUserParams{id, avatart_url, info},
		expectationOrigins: PersistentRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up PersistentRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *PersistentRepositoryMockUpdateUserExpectation) Then(up1 *auth_models.User, err error) *PersistentRepositoryMock {
	e.results = &PersistentRepositoryMockUpdateUserResults{up1, err}
	return e.mock
}

// Times sets number of times PersistentRepository.UpdateUser should be invoked
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Times(n uint64) *mPersistentRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of PersistentRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_auth_usecase.PersistentRepository
func (mmUpdateUser *PersistentRepositoryMock) UpdateUser(id uuid.UUID, avatart_url string, info string) (up1 *auth_models.User, err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(id, avatart_url, info)
	}

	mm_params := PersistentRepositoryMockUpdateUserParams{id, avatart_url, info}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := PersistentRepositoryMockUpdateUserParams{id, avatart_url, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUser.t.Errorf("PersistentRepositoryMock.UpdateUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.avatart_url != nil && !minimock.Equal(*mm_want_ptrs.avatart_url, mm_got.avatart_url) {
				mmUpdateUser.t.Errorf("PersistentRepositoryMock.UpdateUser got unexpected parameter avatart_url, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originAvatart_url, *mm_want_ptrs.avatart_url, mm_got.avatart_url, minimock.Diff(*mm_want_ptrs.avatart_url, mm_got.avatart_url))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdateUser.t.Errorf("PersistentRepositoryMock.UpdateUser got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("PersistentRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the PersistentRepositoryMock.UpdateUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(id, avatart_url, info)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to PersistentRepositoryMock.UpdateUser. %v %v %v", id, avatart_url, info)
	return
}

// UpdateUserAfterCounter returns a count of finished PersistentRepositoryMock.UpdateUser invocations
func (mmUpdateUser *PersistentRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of PersistentRepositoryMock.UpdateUser invocations
func (mmUpdateUser *PersistentRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to PersistentRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mPersistentRepositoryMockUpdateUser) Calls() []*PersistentRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*PersistentRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *PersistentRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *PersistentRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersistentRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersistentRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersistentRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to PersistentRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to PersistentRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PersistentRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetUserByEmailInspect()

			m.MinimockGetUserByIDInspect()

			m.MinimockGetUserByNicknameInspect()

			m.MinimockSaveUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PersistentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PersistentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserByEmailDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserByNicknameDone() &&
		m.MinimockSaveUserDone() &&
		m.MinimockUpdateUserDone()
}
